\subsection{Principles}
Software Design Principles sind weder Regeln, Gesetze noch perfekte Wahrheiten.
Vielmehr sind sie als Empfehlungen oder Ratschläge zu verstehen.
(Vgl.~\cite{getting-a-solid-start})

Software Design Principles sind Heuristiken, die als allgemeingültige Lösungen für übliche Probleme nutzbar sind.
Sie wurden empirisch beobachtet und gelten meistens, allerdings nicht zwingend.
(Vgl.~\cite{getting-a-solid-start})

\subsubsection{SOLID Principles}
Die Kerngruppe der Software Design Prinzipien werden von Robert C. Martin unter dem Titel \enquote{The Principles of OOD}\cite{solid} beschrieben.
Die Grundlage dafür legte er in seiner Veröffentlichung \enquote{Design Principles and Design Patterns}\cite{design-principles-and-design-patterns} im Jahr 2000.

\newlineparagraph{Single Responsibility Principle}
\enquote{A class should have one, and only one, reason to change.}\cite{solid}
Eine Klasse sollte immer so designt werden, dass sie nur einen Zweck erfüllt\cite{different-types-of-software-design-principles}.
Insbesondere für Änderungen ist es wichtig, dass Klassen möglichst klein sind.
Größere Klassen nachzuvollziehen ist komplexer und aufwändiger, Änderungen werden dadurch erschwert.
(Vgl.~\cite{clean-code})

\newlineparagraph{Open Closed Principle}
\enquote{You should be able to extend a classes' behavior, without modifying it.}\cite{solid}
Fertige Klassen sollten nicht mehr verändert werden, lediglich Bugs sollten behoben werden.
Allerdings sollte es immer möglich sein, die Funktionalität zu erweitern.
Deshalb ist es wesentlich, dass die Klassen so entworfen sind, dass Unterklassen die Funktionalität durch Overwrites nicht einschränken können.
Dafür ist es erforderlich, relevante Typen zu definieren und wichtige und finale Methoden auch als solche zu markieren, damit diese nicht mehr verändert werden können.
(Vgl.~\cite{different-types-of-software-design-principles})

\newpage

\newlineparagraph{Liskov Substitution Principle}
\enquote{Derived classes must be substitutable for their base classes.}\cite{solid}
Eine Unterklasse sollte immer genau wie die Oberklasse verwendet werden können, die sie erweitert\cite{different-types-of-software-design-principles}.
Dafür müssen Methodenparameter und -rückgabewerte gleich bleiben.
Neue Exceptions dürfen nur genutzt werden, wenn sie Subklassen der Exceptions sind, die auch in der Oberklasse verwendet werden.

\newlineparagraph{Interface Segregation Principle}
\enquote{Make fine-grained interfaces that are client specific.}\cite{solid}
Interfaces sollten genau wie Klassen möglichst spezifisch sein.
Diese Theorie zielt darauf, dass die implementierenden Klassen nicht gegen das Single Responsibility Principle verstoßen.
Durch kleinere Interfaces müssen die implementierenden Klassen auch nur wesentliche Funktionen implementieren.
Dies vereinfacht sowohl den Einsatz von Interfaces, als auch die Wartung des Codes.
(Vgl.~\cite{design-patterns-php-laravel})

\newlineparagraph{Dependency Inversion Principle}
\enquote{Depend on abstractions, not on concretions.}\cite{solid}
Für eine möglichst lose Kopplung zwischen konkreten Klassen sollten Interfaces und abstrakte Klassen eingesetzt werden.
So wird eine flexiblere Codebase ermöglicht.
Module aus höheren Abstraktionsebenen sollten keine Module von niedrigeren Ebenen importieren.
Die lose Kopplung wird erreicht, wenn zwischen den unterschiedlichen Ebenen abstrakte Interfaces anstatt konkreter Implementierungen genutzt werden.
(Vgl.~\cite{design-patterns-php-laravel})

\newpage

\subsubsection{KISS (Keep It Simple Stupid)}
Das KISS Prinzip wurde ursprünglich im amerikanischen Militär geprägt und ist zurückzuführen auf Kelly Johnson.
(Vgl.~\cite{kelly-johnson-memoir})

Im Bereich Software Design wird das Prinzip darauf bezogen, dass Systeme möglichst einfach gebaut und aus möglichst wenigen Teilen bestehen sollen.
Ebenso sollen Abhängigkeiten und interne Verbindungen reduziert werden.
Zudem soll die Codebasis so gestaltet werden, dass weitere Entwickler, auch Anfänger, die Möglichkeit haben, sie verändern zu können.
(Vgl.~\cite{kiss-principle-explained})

\subsubsection{DRY (Don’t Repeat Yourself)}
Denselben Code immer und immer wieder zu wiederholen ist nicht erstrebenswert.
Werden Wiederholungen bemerkt, sollten sie in Methoden oder andere geeignete Strukturen ausgelagert werden.
Auf diese Weise wird der Code insgesamt kürzer und Wartungen werden einfacher.
(Vgl.~\cite{the-pragmatic-programmer})

Beim Einsatz von Frameworks ist zu beachten, dass diese oft an mehreren Stellen dieselben Konfigurationen benötigen.
Wenn zum Beispiel bei zu erstellenden Klassen ein oder mehrere Attribute auf denselben Wert gesetzt werden sollen, bietet es sich an, eine Oberklasse zu erstellen, die diese Konfiguration bereits setzt.

\subsubsection{YAGNI (You aren't gonna need it)}
Eine Implementierung sollte immer nur dann erfolgen, wenn sie konkret notwendig ist.
Ist lediglich vorhersehbar, dass eine gewisse Funktion notwendig sein wird, sollte sie noch nicht implementiert werden.
(Vgl.~\cite{extreme-programming-installed})

Dieser Grundsatz wurde im Bereich des Extreme Programming geprägt.
Seine Begründung beruht darauf, dass es sich nur selten lohnt, für zukünftige Anforderungen zu entwickeln.
(Vgl.~\cite{kiss-principle-explained})

\subsubsection{PSR (PHP Standards Recommendations)}
Die PHP FIG (Framework Interop Group) arbeitet an und veröffentlicht PSRs (PHP Standards Recommendations).
Eine moderne IDE (Integrierte Entwicklungsumgebung) prüft PHP Code meist auf die PSR-1 (Basic Coding Standard) und vor allem die PSR-12 (Extended Coding Style).
Die PHP-FIG regelt auch weitere Standards, wie zum Beispiel Logger Interfaces, Autoloading und HTTP Features.
(Vgl.~\cite{psr})
