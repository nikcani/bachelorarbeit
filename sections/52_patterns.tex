\subsection{Vergleich anhand von Design Patterns}
Die zu vergleichenden Patterns sind bei Nova und filament nicht dokumentiert.
In beiden Dokumentationen ist allerdings eine Möglichkeit für Komponenten zur Kommunikation mittels Events dokumentiert, dies ist vergleichbar mit dem Publisher-Subscriber Pattern.
Alle weiteren Patterns bzw.\ deren Verwendung sind anhand des Prototyps zu prüfen.

\subsubsection{MVC}
Würde die Sounding Console mit Laravel individuell entwickelt werden, so würde sehr wahrscheinlich dieses Pattern zum Einsatz kommen.
Laravel bereitet Models, Views und Controller bereits vor und ermöglicht deren komfortable Nutzung.
Beim Einsatz von Nova und filament fällt allerdings der Controller weitestgehend weg.
Auch die View, welche klassischerweise in irgendeiner Form HTMl enthalten würde, wird neu gedacht.
Die Frameworks ermöglichen Definitionen von Ressourcen und weiteren Features.
Die daraus resultierenden Views werden durch die Frameworks selbst gerendert und die notwendigen Funktionen eines Controllers sind ebenfalls bereits abgedeckt.

Eine Ausnahme bilden Widgets bei filament und Cards bzw.\ Tools bei Nova.
Bei filament gibt es, neben einer klassischen Blade View, eine Klasse für das Widget, die Aufgaben eines Controllers übernimmt.
Nova nutzt bei Cards bzw.\ Tools View in Vue.js und hängt dazwischen eine Klasse und API Routen, die Funktionen eines Controllers übernehmen können.

Das MVC Pattern wird als nur in Teilen umgesetzt.
Dies ist allerdings von Vorteil, da zentrales Feature beider Frameworks die Vereinfachung der Ressourcenverwaltung ist.
Daher sollen auch kaum bis keine Controller und klassischen Views implementiert werden, da dies mehr Zeit in Anspruch nehmen würde.

\subsubsection{PAC}
Beide Frameworks setzten wie bereits erwähnt eher auf das MVC Pattern.
Das PAC Pattern wird nicht eingesetzt, so wie bei webbasierter Software üblich.

\subsubsection{View Handler}
Wenn mehrere Instanzen der Anwendung unterschiedliche Ansichten zeigen sollen, so kann dieses Pattern zum Einsatz kommen.
Beide Frameworks ermöglichen diese Funktionalität, implementieren diese aber nicht selbst.
Nova und filament sind allerdings so gebaut, dass im Browser mehrere Tabs oder Fenster der Anwendung geöffnet werden können.
Es gibt webbasierte Anwendungen, die durch mehrere geöffnete Instanzen Probleme mit der Session bekommen.
Die betrachteten Frameworks ermöglichen allerdings, dass der Browser als View Handler zum Einsatz kommt.
Dieses Pattern kann daher aus dem Vergleich gestrichen werden, da es zwar zum Einsatz kommt, allerdings in einer anderen Ebene.

\subsubsection{Whole-Part}
\color{red}
Sind passende Probleme mit dem Pattern gelöst?
\color{black}

\subsubsection{Layers}
\color{red}
Sind passende Probleme mit dem Pattern gelöst?
\color{black}

\subsubsection{Publisher-Subscriber}
\color{red}
Sind passende Probleme mit dem Pattern gelöst?
\cite{filament-docs-events}
\cite{nova-docs-events}
\color{black}

\subsubsection{Broker}
\color{red}
Sind passende Probleme mit dem Pattern gelöst?
\color{black}

\subsubsection{Proxy}
\color{red}
Sind passende Probleme mit dem Pattern gelöst?
\color{black}

\subsubsection{Fazit}

\color{red}
Anhand der Tabelle~\ref{tab:bewertung-patterns} wird deutlich, dass XXX in Bezug auf den Einsatz von Patterns besser zu bewerten ist.

\begin{table}[]
    \caption{Bewertung Patterns}
    \label{tab:bewertung-patterns}
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Patterns}    & \textbf{Nova} & \textbf{filament} \\ \hline
        MVC                  & 1             & 1                 \\ \hline
        PAC                  & 0             & 0                 \\ \hline
        Whole-Part           & X             & X                 \\ \hline
        Layers               & X             & X                 \\ \hline
        Publisher-Subscriber & X             & X                 \\ \hline
        Broker               & X             & X                 \\ \hline
        Proxy                & X             & X                 \\ \hline
        \textbf{Summe}       & \textbf{X}    & \textbf{X}        \\ \hline
    \end{tabular}
\end{table}
\color{black}
