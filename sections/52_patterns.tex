\subsection{Vergleich anhand von Design Patterns}
Die zu vergleichenden Patterns sind bei Nova und filament nicht dokumentiert.
In beiden Dokumentationen ist allerdings eine Möglichkeit für Komponenten zur Kommunikation mittels Events dokumentiert, dies ist vergleichbar mit dem Publisher-Subscriber Pattern.
Alle weiteren Patterns bzw.\ deren Verwendung sind anhand des Prototyps zu prüfen.

\subsubsection{MVC}
Würde die Sounding Console mit Laravel individuell entwickelt werden, so würde sehr wahrscheinlich dieses Pattern zum Einsatz kommen.
Laravel bereitet Models, Views und Controller bereits vor und ermöglicht deren komfortable Nutzung.
Beim Einsatz von Nova und filament fällt allerdings der Controller weitestgehend weg.
Auch die View, welche klassischerweise in irgendeiner Form HTMl enthalten würde, wird neu gedacht.
Die Frameworks ermöglichen Definitionen von Ressourcen und weiteren Features.
Die daraus resultierenden Views werden durch die Frameworks selbst gerendert und die notwendigen Funktionen eines Controllers sind ebenfalls bereits abgedeckt.

Eine Ausnahme bilden Widgets bei filament und Cards bzw.\ Tools bei Nova.
Bei filament gibt es, neben einer klassischen Blade View, eine Klasse für das Widget, die Aufgaben eines Controllers übernimmt.
Nova nutzt bei Cards bzw.\ Tools View in Vue.js und hängt dazwischen eine Klasse und API Routen, die Funktionen eines Controllers übernehmen können.

Das MVC Pattern wird als nur in Teilen umgesetzt.
Dies ist allerdings von Vorteil, da zentrales Feature beider Frameworks die Vereinfachung der Ressourcenverwaltung ist.
Daher sollen auch kaum bis keine Controller und klassischen Views implementiert werden, da dies mehr Zeit in Anspruch nehmen würde.

\subsubsection{PAC}
Beide Frameworks setzten wie bereits erwähnt eher auf das MVC Pattern.
Das PAC Pattern wird nicht eingesetzt, so wie bei webbasierter Software üblich.

\subsubsection{View Handler}
Wenn mehrere Instanzen der Anwendung unterschiedliche Ansichten zeigen sollen, so kann dieses Pattern zum Einsatz kommen.
Beide Frameworks ermöglichen diese Funktionalität, implementieren diese aber nicht selbst.
Nova und filament sind allerdings so gebaut, dass im Browser mehrere Tabs oder Fenster der Anwendung geöffnet werden können.
Es gibt webbasierte Anwendungen, die durch mehrere geöffnete Instanzen Probleme mit der Session bekommen.
Die betrachteten Frameworks ermöglichen allerdings, dass der Browser als View Handler zum Einsatz kommt.
Dieses Pattern kann daher aus dem Vergleich gestrichen werden, da es zwar zum Einsatz kommt, allerdings in einer anderen Ebene.

\subsubsection{Whole-Part}
Bei beiden Frameworks ist keine Organisation nach diesem Pattern zu erkennen.
In der Regel kann auf jede Komponente direkt zugegriffen werden.
Semantische Einheiten, bei denen sich dieses Pattern anbieten würde, liegen im aktuellen Projekt auch nicht vor.

\subsubsection{Layers}
Anhand des Prototyps lässt sich bei beiden Frameworks keine Aufteilung in Schichten erkennen.
Die Anwendung ist allerdings auch recht überschaubar und eher auf einer Abstraktionsebene angesiedelt.
Das Layers Pattern wird nicht verwendet.

\subsubsection{Broker}
Es gibt keine passende Probleme für dieses Pattern.
Sowohl mit Nova als auch mit filament wird dieses Pattern nicht umgesetzt.

\newpage

\subsubsection{Publisher-Subscriber}
Nova ermöglicht es JavaScript Komponenten, also vor allem den individuell entwickelten Cards/Tools, über einen Event Bus~\cite{nova-docs-events} zu kommunizieren.
Komponenten können bestimmte Events abonnieren oder Daten veröffentlichen.
Filament ermöglicht Formularen über Events~\cite{filament-docs-events} mit dem Backend zu kommunizieren.
Auch hier können bestimmte Events abonniert oder Daten veröffentlicht werden.

Beide Frameworks verwenden das Pattern, auch wenn sie es anders benennen.
Allerdings ist die Implementierung in beiden Fällen nicht wirklich umfangreich und eher ausbaufähig.
Wünschenswert wäre eine Möglichkeit, die Kommunikation von jeder beliebigen Stelle aus zwischen verschiedenen Komponenten im Frontend und Backend zu ermöglichen.

\subsubsection{Proxy}
Dieses Pattern ist bei beiden Frameworks nicht umgesetzt.
Es gibt auch keine passenden Probleme, für die ein Proxy geeignet wäre.

\subsubsection{Fazit}
Anhand der Tabelle~\ref{tab:bewertung-patterns} ist ersichtlich, dass beide Frameworks die Patterns gleich stark einsetzen.
Es lässt sich kein Unterschied feststellen.

\begin{table}[h!]
    \caption{Bewertung Patterns}
    \label{tab:bewertung-patterns}
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Patterns}    & \textbf{Nova} & \textbf{filament} \\ \hline
        MVC                  & 1             & 1                 \\ \hline
        PAC                  & 0             & 0                 \\ \hline
        Whole-Part           & 0             & 0                 \\ \hline
        Layers               & 0             & 0                 \\ \hline
        Publisher-Subscriber & 1             & 1                 \\ \hline
        Broker               & 0             & 0                 \\ \hline
        Proxy                & 0             & 0                 \\ \hline
        \textbf{Summe}       & \textbf{2}    & \textbf{2}        \\ \hline
    \end{tabular}
\end{table}
