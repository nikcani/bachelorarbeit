\subsection{Vergleich anhand von Design Principles}
Weder in der Dokumentation von Nova, noch in der Dokumentation von filament, sind Principles dokumentiert.
Es ist daher anhand des Prototyps im Detail zu prüfen, ob die jeweiligen Principles durch die Frameworks ermöglicht werden.

\subsubsection{SOLID}
\newlineparagraph{Single Responsibility Principle}
Eine der wichtigsten Verantwortlichkeiten, die beide Frameworks übernehmen, ist die Definition der Ressourcen.
Es wird in beiden Fällen ein Model, welches Daten aus der Datenbank Objekten in PHP zuordnet, als Basis für eine Ressource verwendet.
Damit das jeweilige Framework eine passende UI rendern kann, müssen unterschiedliche Definitionen erfolgen:
So sind Datenbankspalten bzw.\ Model Attribute Formularfeldern zugeordnet.
Auch Relationen zu anderen Model sind anzugeben.
Ebenso erfolgt eine Zuordnung zu Tabellenspalten.
Welche Widgets zusätzlich in der UI einer Ressource gerendert werden, wird ebenfalls definiert.
Außerdem gibt es weitere Einstellungen wie zum Beispiel die Zusammensetzung des Titels einer Ressource oder Filteroptionen.

Bei Nova erfolgen alle diese Definitionen in einer Klasse.
Grundsätzlich kann man dies als eine Verantwortlichkeit im Sinne des Single Responsibility Principle auffassen, jedoch fallen auch schnell Hürden dieser Aufgabenbündelung auf.
So werden zum Beispiel auf unterschiedlichen Seiten einer Ressource, beispielsweise Index und Detail, auch verschiedene Widgets angezeigt.
Bei Nova müssen die unterschiedlichen Fälle dafür in einer Methode geprüft werden und dynamisch definiert werden.

Filament löst die Verantwortlichkeiten besser.
So gibt es für die üblichen vier Unterseiten einer Ressource, aber auch für zusätzliche, je eine eigene Klasse.
Diese regeln die Anzeige der jeweiligen Widgets und die Anzeige von Aktionsschaltflächen.
Es können aber auch je Unterseite weitere Konfigurationen erfolgen, wie zum Beispiel ein angepasstes Formular.
Möglich ist auch, eine standardisierte Unterseite vollständig durch eine individuelle zu ersetzen.

Filament lagert zusätzlich eine weitere Verantwortlichkeit aus.
Relationen werden durch sogenannte \enquote{Relation Manager} in einer eigenen Klasse verwaltet und in der zentralen Resource lediglich referenziert.

Nova trennt Verantwortlichkeiten grundsätzlich vernünftig, ein gutes Beispiel dafür sind die Widgets.
Filament setzt das Principle allerdings im Detail etwas besser um.

\newlineparagraph{Open Closed Principle}
Die zu erweiternden Klassen von Nova und filament sind sehr offen für Veränderungen.
Nahezu keine Methode ist final deklariert.
Das führt dazu, dass auch Methoden überschrieben werden können, die eigentlich nicht angefasst werden sollten.
Grundsätzlich sind notwendige Typen sinnvoll und umfangreich definiert.
Es ist definitiv möglich, das Verhalten von Oberklassen in Unterklassen anzupassen.
Allerdings sind beide Frameworks dabei zu offen gestaltet.

\newlineparagraph{Liskov Substitution Principle}
Dieses Principle betrifft Erweiterungen und damit im Kontext der Frameworks den Teil, für den Entwickler zuständig sind, welche die Frameworks nutzen.
Es ist wichtig, dass die zu erweiternden Klassen wie zum Beispiel Ressourcen, Widgets usw.\ sich an das Liskov Substitution Principle halten.
Ansonsten können Teile des Frameworks nicht mehr korrekt funktionieren.
Die Bewertung auf Basis des Frameworks ist an dieser Stelle also nicht möglich, da die Verantwortlichkeit nicht beim Framework selbst liegt.
Dieses Principle wird daher aus der Betrachtung entfernt.

\newlineparagraph{Interface Segregation Principle}
Beide Frameworks arbeiten intern mit Interfaces.
Nach außen hin werden diese allerdings nicht genutzt.
In der Regel wird ein Feature implementiert, indem eine abstrakte Klasse erweitert wird.
Der zu implementierende Teil ist dabei allerdings stets überschaubar und auf das Nötigste beschränkt.
Grundsätzlich folgen beide Frameworks also dem Principle, allerdings nicht vollständig.

\newlineparagraph{Dependency Inversion Principle}
Dieses Principle wird von keinem Framework befolgt.
Jede höhere Implementierung hängt direkt von einer niedrigeren ab.
Es sind keine Interfaces zwischen als lose Kopplung zwischen die Ebenen geschaltet.

\subsubsection{KISS}
Das KISS Prinzip wird von beiden Frameworks befolgt.
Die Definition von Ressourcen sind in der Regel einfach.
Nova setzt auf implizitere Definitionen.
So werden beispielsweise Felder nur einmal definiert und gelten dann, gemäß definierter Annahmen, nicht nur für das Formular, sondern auch für die Tabellendarstellung.
Bei filament muss alles wesentlich expliziter definiert werden, dies führt teilweise zu Code, der nicht unbedingt notwendig gewesen wäre.

Bei Widgets zeigt sich das umgekehrte Bild.
Aufgrund der unterschiedlichen Architekturen, bei filament Livewire und bei Nova Vue.js, sind unterschiedliche Setups notwendig.
Bei filament lediglich eine einfache Klasse und eine Blade View.
Nova hingegen benötigt einen Ordner mit mindestens 14 Dateien für jedes Widget.
Jedes Widget ist eine eigenständige Vue Komponente, mit Abhängigkeiten und eigenen Backend Routen.
Hinzukommt, dass Widgets gebaut werden müssen bei jeder Änderung.

Insgesamt sind also beide Frameworks ähnlich simpel in ihrem Aufbau und der Art und Weise, wie damit gearbeitet wird.

\color{red}
\subsubsection{DRY}
Wird im Prototyp dieses Principle befolgt?

\subsubsection{YAGNI}
Wird im Prototyp dieses Principle befolgt?

\subsubsection{Fazit}
In der folgenden Tabelle~\ref{tab:bewertung-principles} wird ersichtlich, dass XXX insgesamt besser bei der Umsetzung der Principles zu bewerten ist.

\begin{table}[]
    \caption{Bewertung Principles}
    \label{tab:bewertung-principles}
    \centering
    \begin{tabular}{|l|c|c|}
        \hline
        \textbf{Principle}              & \textbf{Nova} & \textbf{filament} \\ \hline
        Single Responsibility Principle & 1             & 2                 \\ \hline
        Open Closed Principle           & 0             & 0                 \\ \hline
        Interface Segregation Principle & 1             & 1                 \\ \hline
        Dependency Inversion Principle  & 0             & 0                 \\ \hline
        KISS                            & 1             & 1                 \\ \hline
        DRY                             & X             & X                 \\ \hline
        YAGNI                           & X             & X                 \\ \hline
        \textbf{Summe}                  & \textbf{X}    & \textbf{X}        \\ \hline
    \end{tabular}
\end{table}

\color{black}
